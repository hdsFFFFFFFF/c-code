#### C中的NULL指针

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个NULL值是一个良好的编程习惯。。赋值为NULL值的指针被称为空指针。

> NULL指针是一个定义在标准库中的值为零的常量。

```c
#include <stdio.h>
 
int main ()
{
   int  *ptr = NULL;
 
   printf("ptr 的地址是 %p\n", ptr  );
 
   return 0;
}
```

运行结果：

```c
ptr 的地址是 0x0
```

在大多数操作系统上，程序不允许访问地址为0的内存，因为该内存是为操作系统保留的。然而，内存地址0有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值(零值)，则假定它不指向任何东西。



如需检查一个空指针，可以使用if语句，如下所示：

```c
if(ptr)		/* 如果ptr非空，则选中 */
if(!ptr)	/* 如果ptr为空，则选中 */
```



#### C指针的算术运算

C 指针是一个用数值表示的地址。因此，可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。

假设 `ptr` 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：

```c
ptr++
```

在执行完上述的运算之后，`ptr` 将指向位置 1004，因为 `ptr` 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。

如果 `ptr` 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。

概括一下：

- 指针的每一次递增，它其实会指向下一个元素的存储单元
- 指针的每一次递减，它其实会指向前一个元素的存储单元
- 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。



#### 递增一个指针

我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，<u>数组可以看成一个指针常量</u>。下面的程序递增变量指针，以便顺序访问数组中的每一个元素：

> 数组名可以看成是一个指针常量

```c
#include <stdio.h>
 
const int MAX = 3;
 
int main ()
{
   int  var[] = {10, 100, 200};
   int  i, *ptr;
 
   /* 指针中的数组地址 */
   ptr = var;/* 数组名var可以看成是一个指针常量 */
   for ( i = 0; i < MAX; i++)
   {
 
      printf("存储地址：var[%d] = %x\n", i, ptr );
      printf("存储值：var[%d] = %d\n", i, *ptr );
 
      /* 移动到下一个位置 */
      ptr++;
   }
   return 0;
}
```

